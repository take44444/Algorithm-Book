<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RangeBST - アルゴリズムとデータ構造大全</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">アルゴリズムとデータ構造大全</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rangebst"><a class="header" href="#rangebst">RangeBST</a></h1>
<p>扱う座標数を\(N\)とすると，<strong>RangeBST</strong>の各操作と時間計算量は以下．</p>
<ul>
<li>構築: 処理なし</li>
<li>指定された1次元座標に値(モノイドを成す集合の要素)の設置: \(O(\log N)\)</li>
<li>指定された1次元座標の値の更新: \(O(\log N)\)</li>
<li>任意の座標区間の"和"(モノイドにおける2項演算) : \(O(\log N)\)</li>
</ul>
<p>※このRangeBSTという名前は，筆者が勝手につけたもので，このデータ構造には特別名前はなく，中身はBST，つまり<strong>平衡2分探索木</strong>である．平衡2分探索木に機能を追加することで能力を拡張する例は多々あり，これはその1つの例である．</p>
<p><strong>セグメント木と同じ?と思った方もいるかもしれないが，実は少し違う</strong>．セグメント木は，配列に対する区間クエリに対応したもの，つまり，言い換えると<strong>座標に制限(0~配列のサイズ)がある</strong>．RangeBSTは，データを，<strong>座標の集合</strong>としてもつため，座標の値自体に制限がなく，座圧+セグ木で解く必要がある問題も，RangeBSTなら座圧せずに解くことができる(<strong>データ構造内部でも座圧操作をしない！！</strong>)ため，実装が楽になり，実行速度も速くなることがある．</p>
<h2 id="説明"><a class="header" href="#説明">説明</a></h2>
<p>配列に対する区間クエリではないため，最初にサイズを与えたりはしない．使用するメモリ量は，追加した座標の数に比例して動的に増える(座標に重複がある場合は増えない)．</p>
<p>例えば，座標10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150にそれぞれ何かしらの値を設置したとする．このとき，平衡2分探索木でこの集合を持つ形は複数あるが，仮に1番綺麗な形として下のようになったとしよう．</p>
<pre class="mermaid">%%{init: {&quot;flowchart&quot; : { &quot;curve&quot; : &quot;basis&quot; } } }%%
graph TD
80((80)) --- 40((40))
80 --- 120((120))
40 --- 20((20))
40 --- 60((60))
120 --- 100((100))
120 --- 140((140))
20 --- 10((10))
20 --- 30((30))
60 --- 50((50))
60 --- 70((70))
100 --- 90((90))
100 --- 110((110))
140 --- 130((130))
140 --- 150((150))
</pre>
<p>ではここで，座標\(25 \sim 115\)の累積"和"を求めよと言われたら，どこのノードの値の"和"を求めればいいかというと，下の赤い部分である．</p>
<pre class="mermaid">%%{init: {&quot;flowchart&quot; : { &quot;curve&quot; : &quot;basis&quot; } } }%%
graph TD
80((80)):::p --- 40((40)):::p
80 --- 120((120))
40 --- 20((20))
40 --- 60((60)):::p
120 --- 100((100)):::p
120 --- 140((140))
20 --- 10((10))
20 --- 30((30)):::p
60 --- 50((50)):::p
60 --- 70((70)):::p
100 --- 90((90)):::p
100 --- 110((110)):::p
140 --- 130((130))
140 --- 150((150))

classDef p stroke-width:4px,stroke:orangered;
</pre>
<p>もちろんそのままやっていてはノード数分の計算量がかかるが，上の赤く塗られたノードを見ると，平衡2分探索木のおかげである程度まとまった位置に求めたいノードが集まっていることがわかる．</p>
<p>じゃあ<strong>それぞれのノードが自分を根とする部分木の"和"を持っていたら</strong>どうなるかと考えると，見るノードは下の色がついたノードだけでよくなることがわかる．赤いノードはそのノードの値が必要であることを示しており，青いノードはそのノードを根とする部分木の累積"和"が必要であることを示している．</p>
<pre class="mermaid">%%{init: {&quot;flowchart&quot; : { &quot;curve&quot; : &quot;basis&quot; } } }%%
graph TD
80((80)):::v --- 40((40)):::v
80 --- 120((120))
40 --- 20((20))
40 --- 60((60)):::p
120 --- 100((100)):::p
120 --- 140((140))
20 --- 10((10))
20 --- 30((30)):::p
60 --- 50((50))
60 --- 70((70))
100 --- 90((90))
100 --- 110((110))
140 --- 130((130))
140 --- 150((150))

classDef v stroke-width:4px,stroke:orangered;
classDef p stroke-width:4px,stroke:slateblue;
</pre>
<p>とても少なくなった．実は，この工夫だけで，任意区間の累積"和"を求めるのに必要なノード数が\(O(\log N)\)個に抑えられるのである．その理由を説明する．</p>
<p>これは言葉で説明するより図と疑似コードを見た方がわかりやすい．</p>
<p>よりちゃんとした書き方として，累積"和"を取得したい区間を \([25, 115)\)と書く．\([\)は閉区間を意味し，\()\)は開区間を意味する．まず，\(25\)と\(115\)を木上で2分探索(<code>lower_bound</code>)すると，下の緑のノードにたどり着く．また，この2つのノードのLCAをピンク色で示す．</p>
<pre class="mermaid">%%{init: {&quot;flowchart&quot; : { &quot;curve&quot; : &quot;basis&quot; } } }%%
graph TD
80((80)):::lca --- 40((40))
80 --- 120((120)):::lb
40 --- 20((20))
40 --- 60((60))
120 --- 100((100))
120 --- 140((140))
20 --- 10((10))
20 --- 30((30)):::lb
60 --- 50((50))
60 --- 70((70))
100 --- 90((90))
100 --- 110((110))
140 --- 130((130))
140 --- 150((150))

classDef v stroke-width:4px,stroke:orangered;
classDef p stroke-width:4px,stroke:slateblue;
classDef lb stroke-width:4px,stroke:green;
classDef lca stroke-width:4px,stroke:deeppink;
</pre>
<p>左のノードは，LCAまで上りながら，<strong>右の部分木</strong>がある場合だけその累積"和"を累積すればよく，右のノードも同様に，LCAにまで上りながら，<strong>左の部分木</strong>がある場合だけその累積"和"を累積すればよい．わかりづらいと思うので，先ほどの図と重ねてみるとわかりやすい．
　</p>
<pre class="mermaid">%%{init: {&quot;flowchart&quot; : { &quot;curve&quot; : &quot;basis&quot; } } }%%
graph TD
80((80)):::lca --- 40((40)):::v
80 --- 120((120)):::lb
40 --- 20((20))
40 --- 60((60)):::p
120 --- 100((100)):::p
120 --- 140((140))
20 --- 10((10))
20 --- 30((30)):::lb
60 --- 50((50))
60 --- 70((70))
100 --- 90((90))
100 --- 110((110))
140 --- 130((130))
140 --- 150((150))

classDef v stroke-width:4px,stroke:orangered;
classDef p stroke-width:4px,stroke:slateblue;
classDef lb stroke-width:4px,stroke:green;
classDef lca stroke-width:4px,stroke:deeppink;
</pre>
<p>疑似コードを示すとこのようになる．</p>
<pre><code class="language-rs">fn prod(xl: i64, xr: i64) -&gt; S {
  let l: *Node = lower_bound(xl);
  let r: *Node = lower_bound(xr);
  let lca: *Node = get_lca(l, r);
  let lprod: S = e();
  { // 左からLCAまで上りながら右側の部分木を累積
    for (bool f = true; l != lca;) {
      if (f) lprod = op(lprod, l.r.prod_subtree);
      f = l.is_left_child();
      if (f &amp;&amp; l.p != lca) lprod = op(lprod, l.p.v);
      l = l-&gt;p;
    }
  }
  let rprod: S = e();
  { // 右からLCAまで上りながら左側の部分木を累積
    for (bool f = true; r != lca;) {
      if (f) rprod = op(r.l.prod_subtree, rprod);
      f = r.is_right_child();
      if (f &amp;&amp; r.p != lca) rprod = op(r.p.v, rprod);
      r = r-&gt;p;
    }
  }
  return op(op(lprod, lca.v), rprod);
}
</code></pre>
<p>よって，区間クエリの処理は，まず木上で<code>lower_bound</code>し，その次に2つのノードからLCAまで上りながら\(O(1)\)の演算を各ステップで行うだけである．したがって，平衡2分探索木の高さが\(\log N\)であることから，計算量は\(O(\log N)\)となる．</p>
<p>最後に，更新クエリや挿入クエリについて説明する．挿入/更新を\(O(\log N)\)で行えることは平衡2分探索木の章を確認して欲しい．挿入/更新後，ノードの累積"和"の値に影響が出るのは該当ノードの祖先ノード高々\(O(\log N)\)個であるため，それらの値を更新していけばよい．計算量は\(O(\log N) + O(\log N) = O(\log N)\)となる．</p>
<h2 id="実装におけるその他の注意事項"><a class="header" href="#実装におけるその他の注意事項">実装におけるその他の注意事項</a></h2>
<p>モノイドを扱っているため，例のごとく演算の向きを間違えないようにする．</p>
<p>以上！</p>
<h2 id="コード"><a class="header" href="#コード">コード</a></h2>
<p>平衡2分探索木にSplay木を用いた実装．</p>
<p><a href="https://judge.yosupo.jp/submission/75623"><img src="https://img.shields.io/badge/verify-passing-brightgreen" alt="" /></a></p>
<pre><code class="language-cpp">template &lt;class S, S (*op)(S, S), S (*e)()&gt; struct Node {
  Node&lt;S, op, e&gt; *l, *r, *p;
  i64 pt;
  S v, prod_st;
  explicit Node(i64 pt_, S v_)
    : l(nullptr), r(nullptr), p(nullptr), pt(pt_), v(v_), prod_st(v_) {}
  int state() {
    if (p &amp;&amp; p-&gt;l == this) return -1;
    if (p &amp;&amp; p-&gt;r == this) return 1;
    return 0;
  }
  S get_lprod() {
    if (!l) return e();
    return l-&gt;prod_st;
  }
  S get_rprod() {
    if (!r) return e();
    return r-&gt;prod_st;
  }
  void update() {
    prod_st = op(op(get_lprod(), v), get_rprod());
  }
  void rotate() {
    Node&lt;S, op, e&gt; *par = p;
    Node&lt;S, op, e&gt; *mid;
    if (p-&gt;l == this) {
      mid = r; r = par;
      par-&gt;l = mid;
    } else {
      mid = l; l = par;
      par-&gt;r = mid;
    }
    if (mid) mid-&gt;p = par;
    p = par-&gt;p; par-&gt;p = this;
    if (p &amp;&amp; p-&gt;l == par) p-&gt;l = this;
    if (p &amp;&amp; p-&gt;r == par) p-&gt;r = this;
    par-&gt;update(); update();
  }
  void splay() {
    while(state()) {
      int st = state() * p-&gt;state();
      if (st == 0) {
        rotate();
      } else if (st == 1) {
        p-&gt;rotate();
        rotate();
      } else {
        rotate();
        rotate();
      }
    }
  }
};

template &lt;class S, S (*op)(S, S), S (*e)()&gt; struct RangeBST {
private:
  using NC = Node&lt;S, op, e&gt;;
  NC *root, *min_, *max_;
  void splay(NC *node) { node-&gt;splay(), root = node; }
  NC* bound(i64 x, bool lower) {
    NC *valid = nullptr, *left = root, *right = nullptr;
    while (left) {
      valid = left;
      if ((lower &amp;&amp; !(x &gt; left-&gt;pt)) || (!lower &amp;&amp; (x &lt; left-&gt;pt))) {
        right = left;
        left = left-&gt;l;
      } else left = left-&gt;r;
    }
    if (!right &amp;&amp; valid) splay(valid);
    return right;
  }
  void set(i64 x, S val, bool add) {
    NC *nn = new NC(x, val);
    // if no nodes in tree
    if (!root) {
      min_ = nn, max_ = nn, root = nn; return;
    } if (min_-&gt;pt &gt; x) { // if x become min key in tree
      min_-&gt;l = nn, nn-&gt;p = min_, min_ = nn;
      splay(nn); return;
    } if (max_-&gt;pt &lt; x) { // if x become max key in tree
      max_-&gt;r = nn, nn-&gt;p = max_, max_ = nn;
      splay(nn); return;
    }
    NC *node = bound(x, true); // assert node is not null
    if (node-&gt;pt == x) { // if tree already has key x
      if (add) node-&gt;v = op(node-&gt;v, val);
      else node-&gt;v = val;
      node-&gt;update(); splay(node); delete nn; return;
    }
    // now node is first node whose key is larger than x
    nn-&gt;l = node-&gt;l; node-&gt;l = nn;
    nn-&gt;p = node; if (nn-&gt;l) nn-&gt;l-&gt;p = nn;
    nn-&gt;update(); splay(nn);
  }
public:
  RangeBST() : root(nullptr), min_(nullptr), max_(nullptr) {}
  NC* lower_bound(i64 x) {
    NC *ret = bound(x, true);
    if (ret) splay(ret);
    return ret;
  }
  NC* upper_bound(i64 x) {
    NC *ret = bound(x, false);
    if (ret) splay(ret);
    return ret;
  }
  S get(i64 x) {
    NC *ret = lower_bound(x);
    if (!ret || ret-&gt;pt != x) return e();
    return ret-&gt;v;
  }
  void set(i64 x, S val) { set(x, val, false); }
  void add(i64 x, S val) { set(x, val, true); }
  S prod(i64 xl, i64 xr) {
    assert(xl &lt;= xr);
    if (!root || xl &gt; max_-&gt;pt || xr &lt;= min_-&gt;pt) return e();
    if (xl &lt;= min_-&gt;pt &amp;&amp; xr &gt; max_-&gt;pt) return root-&gt;prod_st;
    if (xl &lt;= min_-&gt;pt) return lower_bound(xr)-&gt;get_lprod();
    lower_bound(xl); // now xl is root
    if (xr &gt; max_-&gt;pt) return op(root-&gt;v, root-&gt;get_rprod());
    NC *right = bound(xr, true);
    NC *tmp = right;
    S ret = e();
    for (bool f = true; tmp != root;) {
      if (f) ret = op(tmp-&gt;get_lprod(), ret);
      f = tmp-&gt;state() == 1;
      if (f) ret = op(tmp-&gt;p-&gt;v, ret);
      tmp = tmp-&gt;p;
    }
    if (right) splay(right);
    return ret;
  }
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../range/bbst/splay-tree/main.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../range/imos2d/main.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../range/bbst/splay-tree/main.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../range/imos2d/main.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
    </body>
</html>
